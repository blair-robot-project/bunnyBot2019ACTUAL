package org.usfirst.frc.team449.robot.withSpark;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motion.MotionProfileStatus;
import com.ctre.phoenix.motion.SetValueMotionProfile;
import com.ctre.phoenix.motion.TrajectoryPoint;
import com.ctre.phoenix.motorcontrol.can.BaseMotorController;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANError;
import com.revrobotics.CANSparkMax;
import com.revrobotics.ControlType;
import org.jetbrains.annotations.NotNull;

import java.util.LinkedList;
import java.util.Queue;

/**
 * Subclass of {@link CANSparkMax} that implements {@link BaseMotorController} functionality.
 */
public class SparkMaxMotorController extends CANSparkMax {
    public SparkMaxMotorController(final int deviceID, final MotorType type) {
        super(deviceID, type);
    }

    private ControlType controlMode;

    /**
     * @see BaseMotorController#getControlMode()
     */
    public ControlType getControlMode() {
        return this.controlMode;
    }

    /**
     * Sets the sensor position to the given value.
     *
     * @param sensorPos Position to set for the selected sensor (in raw sensor units).
     * @param pidIdx    0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @param timeoutMs Timeout value in ms. If nonzero, function will wait for
     *                  config success and report an error if it times out.
     *                  If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     * @see BaseMotorController#setSelectedSensorPosition(int, int, int)
     */
    public ErrorCode setSelectedSensorPosition(final int sensorPos, final int pidIdx, final int timeoutMs) {
        // TODO: This method is actually protected, so we might be breaking something by calling it.
        this.setEncPosition(sensorPos);
        return null;
    }

    /**
     * Sets the appropriate output on the talon, depending on the mode.
     *
     * @param mode        The output mode to apply.
     *                    In Position mode, output value is in encoder ticks or an analog value,
     *                    depending on the sensor.
     *                    In Follower mode, the output value is the integer device ID of the talon to
     *                    duplicate.
     * @param outputValue The setpoint value, as described above.
     * @see BaseMotorController#set(com.ctre.phoenix.motorcontrol.ControlMode, double)
     */
    public void set(final ControlType mode, final double outputValue) {
        this.getPIDController().setReference(outputValue, mode);
    }

    /**
     * When trajectory points are processed in the motion profile executer, the MPE determines
     * how long to apply the active trajectory point by summing baseTrajDurationMs with the
     * timeDur of the trajectory point (see TrajectoryPoint).
     * <p>
     * This allows general selection of the execution rate of the points with 1ms resolution,
     * while allowing some degree of change from point to point.
     *
     * @param baseTrajDurationMs The base duration time of every trajectory point.
     *                           This is summed with the trajectory points unique timeDur.
     * @param timeoutMs          Timeout value in ms. If nonzero, function will wait for
     *                           config success and report an error if it times out.
     *                           If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public CANError configMotionProfileTrajectoryPeriod(final int baseTrajDurationMs, final int timeoutMs) {
        return CANError.kNotImplmented;
    }

    public ErrorCode getMotionProfileStatus(@NotNull MotionProfileStatus statusToFill) {
        this.copyStatusTo(statusToFill);
        return ErrorCode.OK;
    }

    public void processMotionProfileBuffer() {
        // TODO: Doesn't seem like the PID controller supports this, so I'm doing this using the encoder.
        // Might need to rework this in case a quadrature encoder is used.
    }

    public int getMotionProfileTopLevelBufferCount() {
        return this.getBufferCount();
    }
    
    /**
     * Trajectory points (called the buffer by CTRE)
     */
    public Queue<TrajectoryPoint> trajPoints = new LinkedList<>();

    /**
     * Set if {@code isUnderrun} ever gets set. Only is cleared by
     * clearMotionProfileHasUnderrun() to ensure robot logic can react or
     * instrument it.
     *
     * @see BaseMotorController#clearMotionProfileHasUnderrun(int)
     */
    private boolean hasUnderrun;
    /**
     * The current output mode of the motion profile executer (disabled,
     * enabled, or hold). When changing the set() value in MP mode, it's
     * important to check this signal to confirm the change takes effect before
     * interacting with the top buffer.
     */
    public SetValueMotionProfile outputEnable;

    /**
     * The selected PID[0] profile slot of current profile
     */
    public int profileSlotSelect;
    /**
     * The selected auxiliary PID[1] profile slot of current profile
     */
    public int profileSlotSelect1;
    private int bufferCapacity;
    private CANEncoder encoder;

    /**
     * Clear the "Has Underrun" flag. Typically this is called after application
     * has confirmed an underrun had occured.
     *
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     * 
     * @see BaseMotorController#clearMotionProfileHasUnderrun(int)
     */
    void clearMotionProfileHasUnderrun(int timeoutMs) {
        this.hasUnderrun = false;
    }

    void clearMotionProfileTrajectories() {
        this.trajPoints.clear();
    }

    ErrorCode pushMotionProfileTrajectory(final TrajectoryPoint pt) {
        // According to Talon' documentation, BaseMotorController returns
        // "CTR_OKAY if trajectory point push ok. ErrorCode if buffer is full due to kMotionProfileTopBufferCapacity."
        if (this.trajPoints.size() >= this.bufferCapacity) return ErrorCode.BufferFull;
        this.trajPoints.add(pt);
        return ErrorCode.OK;
    }

    public int getBufferCount() {
        return this.trajPoints.size();
    }

    /**
     * The available empty slots in the trajectory buffer.
     */
    public int getBufferRem() {
        return this.getBufferCapacity() - this.getBufferCount();
    }

    private int getBufferCapacity() {
        return this.bufferCapacity;
    }

    public boolean hasUnderrun() {
        return this.hasUnderrun;
    }

    /**
     * This is set if Talon/Victor needs to shift a point from its buffer into the
     * active trajectory point however the buffer is empty. This gets cleared
     * automatically when is resolved.
     */
    public boolean isUnderrun() {
        return this.getBufferCount() == 0;
    }

    /**
     * True if the active trajectory point is the last point of the profile.
     */
    public boolean isLast() {
        return !this.trajPoints.isEmpty() && this.trajPoints.peek().isLastPoint;
    }

    public void copyStatusTo(MotionProfileStatus statusToFill) {
        statusToFill.topBufferRem = this.getBufferRem();
        statusToFill.topBufferCnt = this.getBufferCount();
        statusToFill.btmBufferCnt = 0; // Always zero, since there technically isn't a low-level buffer.
        statusToFill.hasUnderrun = this.hasUnderrun();
        statusToFill.isUnderrun = this.isUnderrun();
        statusToFill.activePointValid = this.isActivePointValid();
        statusToFill.isLast = this.isLast();
    }

    /**
     * True if the active trajectory point is not empty, false otherwise. The
     * members in activePoint are only valid if this signal is set.
     */
    public boolean isActivePointValid() {
        return !this.isUnderrun(); // TODO: Dubious that this is how this actually works.
    }

    public TrajectoryPoint peekActivePoint() {
        return this.trajPoints.peek();
    }

    public TrajectoryPoint consumeActivePoint() {
        return this.trajPoints.remove();
    }

    /**
     * The duration in ms of the current trajectory point.
     */
    public int getTimeDurMs() {
        return this.peekActivePoint().timeDur.value;
    }
}