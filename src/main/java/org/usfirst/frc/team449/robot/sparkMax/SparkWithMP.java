package org.usfirst.frc.team449.robot.sparkMax;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motion.MotionProfileStatus;
import com.ctre.phoenix.motion.TrajectoryPoint;
import com.ctre.phoenix.motorcontrol.can.BaseMotorController;
import com.revrobotics.CANError;
import com.revrobotics.CANSparkMax;
import com.revrobotics.ControlType;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.usfirst.frc.team449.robot.other.Clock;
import org.usfirst.frc.team449.robot.other.Logger;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Subclass of {@link CANSparkMax} that implements {@link BaseMotorController} functionality.
 */
public class SparkWithMP extends CANSparkMax {
    private ControlType controlType;
    private int basePointDuration;

    private boolean isUnderrun;
    private TrajectoryPoint activePoint;
    private long activePointActivationTime;

    SparkWithMP(final int deviceID, final MotorType type) {
        super(deviceID, type);
    }

    /**
     * @see BaseMotorController#getControlMode()
     */
    @Contract(pure = true)
    public ControlType getControlType() {
        return this.controlType;
    }

    /**
     * Sets the sensor position to the given value.
     *
     * @param sensorPos Position to set for the selected sensor (in raw sensor units).
     * @param pidIdx    0 for Primary closed-loop. 1 for cascaded closed-loop.
     * @param timeoutMs Timeout value in ms. If nonzero, function will wait for
     *                  config success and report an error if it times out.
     *                  If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     * @see BaseMotorController#setSelectedSensorPosition(int, int, int)
     */
    public CANError setSelectedSensorPosition(final int sensorPos, final int pidIdx, final int timeoutMs) {
        // TODO: This method is actually protected, so we might be breaking something by calling it.
        this.setEncPosition(sensorPos);
        return CANError.kOk;
    }

    /**
     * TODO: I think you're correct in that there's no way to retrieve the mode from the controller.
     * Sets the value and the control type.
     *
     * @param outputValue The value to set, which depends on the control mode:
     *                    * For basic control using duty cycle, this should range between -1 and 1.
     *                    * For voltage control, this is the voltage in volts.
     *                    * For velocity control, this is the angular velocity in RPM.
     *                    * For position control, this is the rotation value.
     *                    * For current control, this is the current in amps.
     * @param mode        The control type to override with.
     * @see BaseMotorController#set(com.ctre.phoenix.motorcontrol.ControlMode, double, double)
     */
    public void setReference(final ControlType mode, final double outputValue) {
        Logger.addEvent("setReference: mode=" + mode + " value=" + outputValue, this.getClass());
        System.out.println("setReference: mode=" + mode + " value=" + outputValue);
        this.getPIDController().setReference(outputValue, mode);
        this.controlType = mode;
    }

    public void setPointReference(final double pos, final double vel, final double acc) {
        this.setReference(ControlType.kSmartMotion, pos);
        this.getPIDController().setSmartMotionMaxVelocity(vel, 0); // TODO This must be changed if we have slot-switching
        this.getPIDController().setSmartMotionMaxAccel(acc, 0);
    }

    public void setPointReference(final TrajectoryPoint point) {
        this.setPointReference(point.position, point.velocity, 0);
    }

    /**
     * When trajectory points are processed in the motion profile executer, the MPE determines
     * how long to apply the active trajectory point by summing baseTrajDurationMs with the
     * timeDur of the trajectory point (see TrajectoryPoint).
     * <p>
     * This allows general selection of the execution rate of the points with 1ms resolution,
     * while allowing some degree of change from point to point.
     *
     * @param baseTrajDurationMs The base duration time of every trajectory point.
     *                           This is summed with the trajectory points unique timeDur.
     * @param timeoutMs          Timeout value in ms. If nonzero, function will wait for
     *                           config success and report an error if it times out.
     *                           If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public CANError configMotionProfileTrajectoryPeriod(final int baseTrajDurationMs, final int timeoutMs) {
        this.basePointDuration = baseTrajDurationMs;
        return CANError.kOk;
    }

    public CANError getMotionProfileStatus(@NotNull final MotionProfileStatus statusToFill) {
        this.copyStatusTo(statusToFill);
        return CANError.kOk;
    }

    @Contract(pure = true)
    public int getMotionProfileTopLevelBufferCount() {
        return this.pointQueue.size();
    }

    /**
     * Trajectory points (called the buffer by CTRE)
     */
    private final Queue<TrajectoryPoint> pointQueue = new ConcurrentLinkedQueue<>();

    /**
     * Set if {@code isUnderrun} ever gets set. Only is cleared by
     * clearMotionProfileHasUnderrun() to ensure robot logic can react or
     * instrument it.
     *
     * @see BaseMotorController#clearMotionProfileHasUnderrun(int)
     */
    private boolean hasUnderrun;

    /**
     * The selected PID[0] profile slot of current profile
     */
    public int profileSlotSelect;
    /**
     * The selected auxiliary PID[1] profile slot of current profile
     */
    public int profileSlotSelect1;

    public static final int MotionProfileBufferCapacity = 2048;

    /**
     * Clear the "Has Underrun" flag. Typically this is called after application
     * has confirmed an underrun had occured.
     *
     * @param timeoutMs Timeout value in ms. If nonzero, function will wait for config
     *                  success and report an error if it times out. If zero, no
     *                  blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     * @see BaseMotorController#clearMotionProfileHasUnderrun(int)
     */
    void clearMotionProfileHasUnderrun(final int timeoutMs) {
        this.hasUnderrun = false;
    }

    void clearMotionProfileTrajectories() {
        this.pointQueue.clear();
    }

    ErrorCode pushMPPoint(final TrajectoryPoint pt) {
        // According to Talon' documentation, BaseMotorController returns
        // "CTR_OKAY if trajectory point push ok. ErrorCode if buffer is full due to kMotionProfileTopBufferCapacity."
        if (this.getBufferRemaining() <= 0) return ErrorCode.BufferFull;
        this.pointQueue.add(pt);
        return ErrorCode.OK;
    }

    /**
     * The number of available empty slots in the trajectory buffer.
     */
    @Contract(pure = true)
    public int getBufferRemaining() {
        return SparkWithMP.MotionProfileBufferCapacity - this.getMotionProfileTopLevelBufferCount();
    }

    @Contract(pure = true)
    public boolean hasUnderrun() {
        return this.hasUnderrun;
    }

    /**
     * This is set if Talon/Victor needs to shift a point from its buffer into the
     * active trajectory point however the buffer is empty. This gets cleared
     * automatically when is resolved.
     */
    @Contract(pure = true)
    public boolean isUnderrun() {
        return this.isUnderrun;
    }

    /**
     * True if the active trajectory point is the last point of the profile.
     */
    @Contract(pure = true)
    public boolean isLast() {
        return !this.pointQueue.isEmpty() && this.pointQueue.peek().isLastPoint;
    }

    @Contract(pure = true)
    public void copyStatusTo(final MotionProfileStatus statusToFill) {
        statusToFill.topBufferRem = this.getBufferRemaining();
        statusToFill.topBufferCnt = this.getMotionProfileTopLevelBufferCount();
        statusToFill.btmBufferCnt = 0; // Always zero, since there is no low-level buffer. TODO Should it actually be 1?
        statusToFill.hasUnderrun = this.hasUnderrun();
        statusToFill.isUnderrun = this.isUnderrun();
        statusToFill.activePointValid = this.isActivePointValid();
        statusToFill.isLast = this.isLast();
    }

    /**
     * True if the active trajectory point is not empty, false otherwise. The
     * members in activePoint are only valid if this signal is set.
     */
    @Contract(pure = true)
    public boolean isActivePointValid() {
        return !this.isUnderrun(); // TODO: Actually whether the point is empty.
    }

    @Contract(pure = true)
    public TrajectoryPoint activePoint() {
        return this.activePoint;
    }

    /**
     * The duration in ms of the current trajectory point.
     */
    @Contract(pure = true)
    public int getTimeDurMs() {
        return this.basePointDuration + this.activePoint().timeDur;
    }

    /**
     * Moves on to the next point if the active point needs to be consumed.
     */
    public void processMotionProfile() {
        if (this.activePointShouldBeConsumed()) this.moveToNextPoint();
    }

    private void moveToNextPoint() {
        final TrajectoryPoint newActivePoint = this.activePoint = this.pointQueue.poll();
        this.hasUnderrun |= (this.isUnderrun = newActivePoint == null);
        if (!this.hasUnderrun) {
            this.setPointReference(this.activePoint());
            this.activePointActivationTime = Clock.currentTimeMillis();
        }
    }

    @Contract(pure = true)
    private boolean activePointShouldBeConsumed() {
        // Always if we're underrun.
        if (!this.isActivePointValid()) return true;

        // Check if the current point has been running for its target duration.
        return this.getTimeDurMs() >= Clock.currentTimeMillis() - this.activePointActivationTime;
    }
}
